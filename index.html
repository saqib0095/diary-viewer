<link href='https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.css' rel='stylesheet' /> 
<script src='https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.js'></script> 
<div id='calendar-container' style="font-family: sans-serif; background: white; padding: 15px; border-radius: 8px;"> 
  <div id='status' style="text-align:center; color: #666; margin-bottom: 10px;">Checking Timetastic...</div> 
  <div id='calendar'>
  </div> 
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const calendarEl = document.getElementById('calendar');
  const statusEl = document.getElementById('status');
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  
  const calendar = new FullCalendar.Calendar(calendarEl, {
    initialView: 'dayGridMonth',
    height: "auto",
    headerToolbar: {
      left: 'prev,next today',
      center: 'title',
      right: 'dayGridMonth,listMonth'
    },

   events: async function(info, successCallback, failureCallback) {
  statusEl.innerHTML = "Syncing data...";

  const format = d => {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  };

  // normalize to month boundaries
  let cursor = new Date(info.start.getFullYear(), info.start.getMonth(), 1);
  const endRange = new Date(info.end.getFullYear(), info.end.getMonth() + 1, 0);

  const allEvents = [];

  try {
    while (cursor <= endRange) {
      const monthStart = new Date(cursor.getFullYear(), cursor.getMonth(), 1);
      const monthEnd = new Date(cursor.getFullYear(), cursor.getMonth() + 1, 0);

      const startStr = format(monthStart) + "T00:00:00";
      const endStr = format(monthEnd) + "T23:59:59";

      const url = `https://timetastic-proxy.onrender.com/diary?from=${startStr}&to=${endStr}`;
      console.log("Fetching:", url);

      const response = await fetch(url);

     let retries = 0;
      while (cursor <= endRange) {
          try {
              // fetch logic here
              retries = 0; // reset on success
          } catch(e) {
              if (retries < 5) {
                  retries++;
                  await sleep(2000);
                  continue;
              } else {
                  throw e;
              }
          }
      }


      const data = await response.json();

      data.forEach(day => {
        if (!day.absences) return;

        day.absences.forEach(abs => {
          if (abs.absenceType === "PublicHoliday") return;

          allEvents.push({
            title: abs.userName,
            start: day.date,
            allDay: true
          });
        });
      });
      await sleep(1000); // throttle requests
      //next month
      cursor = new Date(cursor.getFullYear(), cursor.getMonth() + 1, 1);

      // next month
      //cursor = new Date(cursor.getFullYear(), cursor.getMonth() + 1, 1);
    }

    statusEl.innerHTML = "";
    successCallback(allEvents);

  } catch (error) {
    console.error("Fetch failed:", error);
    statusEl.innerHTML = "Connection error";
    failureCallback(error);
  }
}

// closes events
  }); // closes calendar config

  calendar.render();
});
</script>
